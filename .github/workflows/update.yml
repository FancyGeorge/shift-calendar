name: System Config Loader

on:
  schedule:
    - cron: "0 * * * *"   # Runs every hour
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install ics pytz

      - name: Fetch Config Data
        env:
          SECRET_URL: ${{ secrets.PAT_TOKEN }} 
        run: |
          # 1. SECURITY CHECK
          SECRET_LEN=${#SECRET_URL}
          if [ "$SECRET_LEN" -lt 10 ]; then
             echo "CRITICAL ERROR: Secret is empty."
             exit 1
          fi
          
          # 2. DOWNLOAD
          CLEAN_URL=$(echo "$SECRET_URL" | tr -d ' "')
          curl -v -L -o raw_data.tmp "$CLEAN_URL" \
            -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)"

      - name: Process Config
        run: |
          python3 << 'EOF'
          from ics import Calendar, Event
          from datetime import datetime, timedelta
          import os
          import sys
          import pytz

          # === SETUP ===
          shifts_cal = Calendar()   # For your actual work schedule
          status_cal = Calendar()   # For the heartbeat/error log
          
          now = datetime.now()
          ab_tz = pytz.timezone('America/Edmonton')
          
          # === CHECK: MISSING FILE ===
          if not os.path.exists("raw_data.tmp"): 
              # WRITE ERROR TO STATUS CALENDAR
              err = Event()
              err.name = "❌ ERROR: Download Failed"
              err.begin = now
              err.duration = timedelta(hours=1)
              err.uid = f"error-{now.strftime('%Y%m%d%H%M')}"
              status_cal.events.add(err)
              
              with open("status_log.ics", "w") as f:
                  f.write(status_cal.serialize())
              
              print("::error::Download failed. Status log updated with ERROR.")
              # We do NOT save the shifts calendar, keeping the old safe version.
              sys.exit(0) # Exit success so we can commit the error log

          with open("raw_data.tmp", "r", encoding="utf-8") as f:
              raw_text = f.read()

          try:
              calendars = Calendar.parse_multiple(raw_text)
          except:
              print("::error::File corrupted.")
              sys.exit(1)

          event_count = 0

          # === PROCESSING LOOP ===
          for cal in calendars:
              for e in cal.events:
                  try:
                      title = (e.name or "").strip()
                      start = e.begin
                      end = e.end
                      
                      if not start or not end: continue
                      if title == "X": continue

                      # RENAMING LOGIC
                      duration_hours = (end - start).total_seconds() / 3600
                      local_start = start.astimezone(ab_tz)
                      h = local_start.hour

                      if 11 <= duration_hours <= 13:
                          if 6 <= h <= 8: title = "D12"
                          elif 9 <= h <= 11: title = "E12"
                          elif 18 <= h <= 20: title = "N12"

                      # TRUNCATE OVERNIGHT
                      if end.date() > start.date():
                          end = start.replace(hour=23, minute=55)

                      new = Event()
                      new.name = title
                      new.begin = start
                      new.end = end
                      new.uid = f"{start.strftime('%Y%m%d%H%M')}-{title.replace(' ', '')}-sys-log"
                      
                      shifts_cal.events.add(new)
                      event_count += 1
                  except:
                      continue

          # === STATUS REPORTING ===
          
          if event_count < 5:
             # SOFT FAILURE: Update Status Log with Warning, but keep old shifts
             warn = Event()
             warn.name = f"⚠️ WARNING: Only {event_count} shifts found"
             warn.begin = now
             warn.duration = timedelta(minutes=60)
             warn.uid = f"warn-{now.strftime('%Y%m%d%H%M')}"
             status_cal.events.add(warn)
             
             with open("status_log.ics", "w") as f:
                 f.write(status_cal.serialize())
             
             print(f"::error::SAFETY TRIGGER: Low event count ({event_count}). Log updated.")
             # We exit successfully so Git saves the warning file, but we do NOT save the broken shifts file
             sys.exit(0) 

          else:
             # SUCCESS: Save Shifts AND Heartbeat
             
             # 1. Save the Clean Shifts
             with open("sys_config_8x92.ics", "w") as f:
                 f.write(shifts_cal.serialize())

             # 2. Update the Status Log (Heartbeat)
             # We make this an ALL DAY event so it floats at the top, out of the way
             heartbeat = Event()
             heartbeat.name = f"✅ System Healthy ({event_count} shifts)"
             heartbeat.begin = now.date() # All day event
             heartbeat.make_all_day()
             heartbeat.uid = f"heartbeat-{now.strftime('%Y%m%d')}"
             status_cal.events.add(heartbeat)
             
             with open("status_log.ics", "w") as f:
                 f.write(status_cal.serialize())

          print(f"SUCCESS: Split files generated.")
          EOF

      - name: Update Config
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add BOTH files
          git add sys_config_8x92.ics
          git add status_log.ics
          
          git rm --cached clean_shifts.ics || true
          
          git commit -m "Update system configuration" || echo "No changes"
          git push
